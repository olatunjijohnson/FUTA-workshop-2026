{"title":"Day 2 – Joint modelling and Non-stationary processes","markdown":{"yaml":{"title":"Day 2 – Joint modelling and Non-stationary processes","author":"Olatunji Johnson","freeze":"auto","format":"html","editor":"visual","execute":{"echo":true,"warning":false,"message":false}},"headingText":"Overview","containsRefs":false,"markdown":"\n\n\nToday we will cover two key advanced topics in spatial modelling:\n\n1.  **Joint modelling** of multiple malaria processes\n    -   Shared spatial fields\\\n    -   Process-specific fields\\\n    -   Multiple outcomes (e.g., children vs pregnant women)\n    -   Multiple likelihoods (Binomial + Poisson)\n2.  **Non-stationary spatial processes**\n    -   Region-varying smoothness\\\n    -   Covariate-driven nonstationarity\\\n    -   Combining multiple spatial SPDEs\n\n------------------------------------------------------------------------\n\n## 1. Load Day 2 datasets\n\n```{r}\nlibrary(tidyverse)\nlibrary(INLA)\nlibrary(inlabru)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(stars)\nlibrary(geoR)\n\njoint_malaria <- read_csv(\"data/joint_malaria_processes.csv\")\nnonstat_malaria <- read_csv(\"data/nonstationary_malaria_data.csv\")\n\nnga_admin1 <- st_read(\"data/nga_shapefile.shp\")\n\nhead(joint_malaria)\n```\n\n## 2. Convert to sf for mapping\n\nWe need an `sf` layer to overlay boundaries, plot points, and feed coordinates into SPDE meshes.\n\n```{r}\njoint_malaria_sf <- joint_malaria %>%\n  st_as_sf(coords = c(\"utm_x\", \"utm_y\"), crs = 32632)\nnonstat_malaria_sf <- nonstat_malaria %>%\n  st_as_sf(coords = c(\"utm_x\", \"utm_y\"), crs = 32632)\n```\n\n## 3. Quick visualisation\n\n```{r}\nggplot() +\ngeom_sf(data = joint_malaria_sf, aes(colour = prevalence_true)) +\nfacet_wrap(~group) +\ngeom_sf(data = nga_admin1, fill = NA) +\ngeom_point() +\ntheme_minimal()\n```\n\nQuick visualisation (non-stationary dataset)\n\n```{r}\nggplot() +\ngeom_sf(data = nonstat_malaria_sf, aes(colour = prevalence_true)) +\ngeom_sf(data = nga_admin1, fill = NA) +\ngeom_point() +\ntheme_minimal()\n```\n\n============================================================\n\n**Part 1A — Joint modelling (shared + group-specific fields)**\n\n============================================================\n\n## 4.  Create a single stacked dataset\n\nWe will model both groups jointly with: - one shared spatial field - one group-specific spatial field (replicated by group)\n\n```{r}\njoint_dat <- joint_malaria_sf |>\nmutate(\ngroup = factor(group),\ny = n_pos,\nn = n_tested\n)\n\nlevels(joint_dat$group)\n```\n\n## 5.  Build SPDE mesh\n\n```{r}\nlocs_joint <- joint_malaria_sf\n\nmesh_joint <- inla.mesh.2d(\nloc = st_coordinates(locs_joint),\nmax.edge = c(80000, 250000),   # tune for smoothness vs speed\ncutoff = 20000,                # remove very close points\noffset = c(100000, 200000)\n)\n\nplot(mesh_joint)\npoints(st_coordinates(locs_joint), pch = 16, cex = 0.4, col= \"red\")\n```\n\n## 6.  Define SPDEs (shared + group-specific)\n\n-   spde_shared: one latent field for all data\n-   spde_group: replicated field with one replicate per group\n\n```{r}\nspde_shared <- inla.spde2.pcmatern(\nmesh = mesh_joint,\nprior.range = c(300000, 0.5),   # P(range < 300km) = 0.5\nprior.sigma = c(1, 0.5)         # P(sigma > 1) = 0.5\n)\n\nspde_group <- inla.spde2.pcmatern(\nmesh = mesh_joint,\nprior.range = c(200000, 0.5),\nprior.sigma = c(1, 0.5)\n)\n```\n\n## 7.  Fit joint model in inlabru\n\nModel:\n\n-   Binomial likelihood for counts\n-   Fixed effects (elevation, ndvi, urban)\n-   field_shared() applies to all\n-   field_group() replicated by group\n\n```{r}\ncmp_joint <- y ~\n1 +\nelevation + ndvi + urban +\nfield_shared(geometry, model = spde_shared) +\nfield_group(geometry, model = spde_group, replicate = group)\n\nfit_joint <- bru(\ncomponents = cmp_joint,\nfamily = \"binomial\",\ndata = joint_dat,\nNtrials = joint_dat$n,\noptions = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_joint)\n```\n\n## 8.  Prediction grid inside Nigeria (UTM)\n\n```{r}\n# make_grid_utm <- function(polygon_utm, dx = 20000) {\n# bb <- st_bbox(polygon_utm)\n# xs <- seq(bb[\"xmin\"], bb[\"xmax\"], by = dx)\n# ys <- seq(bb[\"ymin\"], bb[\"ymax\"], by = dx)\n# grid <- expand.grid(utm_x = xs, utm_y = ys)\n# pts  <- st_as_sf(grid, coords = c(\"utm_x\", \"utm_y\"), crs = st_crs(polygon_utm))\n# inside <- st_within(pts, polygon_utm, sparse = FALSE)[, 1]\n# grid[inside, ]\n# }\n# \n# pred_grid_joint <- make_grid_utm(nga_poly %>% st_transform(32632), dx = 100000) |>\n# mutate(\n# # For teaching: use simple smooth-ish covariates (replace with real rasters later)\n# elevation = 250 + 80 * scale(utm_y)[,1] + rnorm(n(), sd = 15),\n# ndvi      = plogis(-0.2 + 0.8 * scale(utm_y)[,1] + 0.3 * sin(scale(utm_x)[,1])),\n# urban     = rbinom(n(), 1, plogis(-0.2 + 0.3 * scale(utm_x)[,1]))\n# )\n\npred_grid_joint <- read_csv(\"data/prediction_grid_utm.csv\") %>% \ntidyr::expand_grid(group = levels(joint_dat$group)) %>%\nst_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\nhead(pred_grid_joint)\n```\n\n## 9.  Predict for each group and map\n\n```{r}\npred_joint <- predict(\nfit_joint,\nnewdata = pred_grid_joint,\nformula = ~ plogis(Intercept + elevation + ndvi + urban +\nfield_shared + field_group),\nn.samples = 200\n)\n\npred_joint_sf <- pred_joint |>\nrename(prev_mean = mean)\n\nhead(pred_joint_sf)\n```\n\n## 10.  Raster map per group (clipped to Nigeria)\n\n```{r}\npred_joint_map <- function(group_name, dx = 20000) {\ndat_g <- pred_joint_sf |> filter(group == group_name)\n\nrast <- st_rasterize(dat_g[\"prev_mean\"], dx = dx, dy = dx)\nrast_ng <- rast[st_union(nga_admin1)]\n\nggplot() +\ngeom_stars(data = rast_ng, na.rm = TRUE) +\ngeom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\ncoord_sf(expand = FALSE) +\nscale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\ntheme_minimal() +\ntheme(panel.grid = element_blank(),\npanel.background = element_rect(fill = \"white\", colour = NA),\nplot.background  = element_rect(fill = \"white\", colour = NA)) +\nlabs(title = paste(\"Joint model: posterior mean prevalence –\", group_name))\n}\n\npred_joint_map(\"children_u5\")\npred_joint_map(\"pregnant_women\")\n```\n\n============================================================\n\n**Part 2A — Joint modelling with multiple likelihoods (Binomial + Poisson)**\n\n============================================================\n\n## 11.  Prepare the two datasets and create the mesh\n\nHere we used the binomial and poisson malaria data: - spatial_binom with n_pos, n_tested - spatial_pois with cases, population\n\n```{r}\n# Example: take children as binomial and pretend pregnant are poisson (toy)\nbinom_dat <- read_csv(\"data/spatial_binomial_data.csv\") \npois_dat <- read_csv(\"data/spatial_poisson_data.csv\")\n\nbinom_sf <- st_as_sf(binom_dat, coords = c(\"utm_x\",\"utm_y\"), crs = 32632)\npois_sf  <- st_as_sf(pois_dat,  coords = c(\"utm_x\",\"utm_y\"), crs = 32632)\n\n\nmesh_binom <- inla.mesh.2d(\nloc = st_coordinates(binom_sf),\nmax.edge = c(100000, 200000), # inner and outer triangle sizes\ncutoff = 20000,  # merge points closer than 20km\noffset = c(50000, 200000)  # extend mesh beyond convex hull\n)\n\nplot(mesh_binom)\npoints(st_coordinates(binom_sf), col=\"red\", pch=16, cex = 0.4)\n\n\n####\nmesh_pois <- inla.mesh.2d(\nloc = st_coordinates(binom_sf),\nmax.edge = c(100000, 200000), # inner and outer triangle sizes\ncutoff = 20000,  # merge points closer than 20km\noffset = c(50000, 200000)  # extend mesh beyond convex hull\n)\n\nplot(mesh_pois)\npoints(st_coordinates(binom_sf), col=\"red\", pch=16, cex = 0.4)\n\n\n# Mesh on all locations\nall_coords <- rbind(st_coordinates(binom_sf), st_coordinates(pois_sf))\n\nmesh_joint <- inla.mesh.2d(\n  loc = all_coords,\n  max.edge = c(80000, 250000),\n  cutoff   = 20000,\n  offset   = c(100000, 200000)\n)\n\nplot(mesh_joint); points(all_coords, pch = 16, cex = 0.4, col=\"red\")\n```\n\n## 12.  Shared + likelihood-specific spatial fields\n\n```{r}\nspde_shared <- inla.spde2.pcmatern(\n  mesh = mesh_joint,\n  prior.range = c(300000, 0.5),\n  prior.sigma = c(1, 0.5)\n)\n\nspde_binom <- inla.spde2.pcmatern(\n  mesh = mesh_binom,\n  prior.range = c(200000, 0.5),\n  prior.sigma = c(1, 0.5)\n)\n\nspde_pois <- inla.spde2.pcmatern(\n  mesh = mesh_pois,\n  prior.range = c(200000, 0.5),\n  prior.sigma = c(1, 0.5)\n)\n```\n\n## 13.  Fit a multi-likelihood model in inlabru\n\nKey idea: use like() twice, and call bru() once.\n\n```{r}\n# Components: shared + outcome-specific fields\ncmp <- ~\n  Intercept_binom(1) + Intercept_pois(1) + \n  elevation + ndvi + urban +\n  shared(geometry, copy = \"binom_field\", fixed = FALSE) +\n  binom_field(geometry, model = spde_binom) +\n  pois_field(geometry,  model = spde_pois)\n\n# Likelihood 1: binomial prevalence\nlike_binom <- like(\n  formula = n_pos ~ Intercept_binom + elevation + ndvi + urban +\n  binom_field,\n  family  = \"binomial\",\n  data    = binom_sf,\n  Ntrials = binom_sf$n_tested\n)\n\n# Likelihood 2: poisson cases with offset(log(population))\nlike_pois <- like(\n  formula = cases ~ Intercept_pois + elevation + ndvi + urban +\n  shared +\n  pois_field, # + offset(log(population)),\n  family  = \"poisson\",\n  data    = pois_sf,\n  E = pois_sf$population\n)\n\nfit_multi <- bru(\n  components = cmp,\n  like_binom,\n  like_pois,\n  options = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_multi)\n```\n\n## 14.  Predict (example: prevalence surface from the binomial part)\n\n```{r}\npred_grid <- read_csv(\"data/prediction_grid_utm.csv\") %>%\nst_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\n\npred_binom_multi <- predict(\nfit_multi,\nnewdata = pred_grid,\nformula = ~ plogis(Intercept_binom + elevation + ndvi + urban + binom_field),\nn.samples = 1000\n)\n```\n\n```{r}\npred_binom_r <- st_rasterize(pred_binom_multi[\"mean\"], dx=10000, dy=10000)\npred_binom_r <- pred_binom_r[st_union(nga_admin1)]\nggplot() +\n  geom_stars(data=pred_binom_r, na.rm = TRUE) +\n  geom_sf(data=nga_admin1, fill=NA, color = \"black\") +\n  coord_sf() +\n  scale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = NA),\n    plot.background  = element_rect(fill = \"white\", colour = NA),\n    panel.grid       = element_blank()\n  )\n\n```\n\n============================================================\n\n**Part 1B — Non-stationary spatial process (mixture of two SPDEs)**\n\n============================================================ We’ll fit a non-stationary field using a mixture of two spatial fields:\n\n-   one smooth / long-range SPDE\n-   one rough / short-range SPDE\n-   a spatially varying weight w(s) controlling mixture\n\nThis is a simple, teachable non-stationary construction.\n\n## 15.  Prepare data and a mesh\n\n```{r}\nns_dat <- nonstat_malaria |>\nmutate(\ny = n_pos,\nn = n_tested\n)\n\nlocs_ns <- nonstat_malaria_sf\n\nmesh_ns <- inla.mesh.2d(\nloc = st_coordinates(locs_ns),\nmax.edge = c(80000, 250000),\ncutoff = 20000,\noffset = c(100000, 200000)\n)\n\nplot(mesh_ns)\npoints(st_coordinates(locs_ns), pch = 16, cex = 0.4, col= \"red\")\n```\n\n## 15.  Two SPDEs: smooth and rough\n\n```{r}\nspde_smooth <- inla.spde2.pcmatern(\nmesh = mesh_ns,\nprior.range = c(600000, 0.5),   # long range\nprior.sigma = c(1, 0.5)\n)\n\nspde_rough <- inla.spde2.pcmatern(\nmesh = mesh_ns,\nprior.range = c(200000, 0.5),   # short range\nprior.sigma = c(1, 0.5)\n)\n```\n\n## 16.  Build a spatially varying weight w(s)\n\nDefine w(s) as a simple function of northing (utm_y). (You can later replace this with a covariate surface.)\n\n```{r}\n# Normalised northing in [0,1]\n\nns_dat <- ns_dat |>\nmutate(\nw = (utm_y - min(utm_y)) / (max(utm_y) - min(utm_y)),\nw = pmin(pmax(w, 0), 1)\n) %>% st_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\nhead(ns_dat)\n```\n\n## 17.  Fit non-stationary mixture model\n\nWe model:\n\n$$\\eta = \\beta_0 + \\beta^\\top x(s) + \\omega(s) S_{smooth} + (1- \\omega(s)) S_{rough}(s)$$\n\nIn inlabru we do this by multiplying the fields by covariates w and 1-w.\n\n```{r}\ncmp_ns <- y ~\n1 + elevation + ndvi + urban +\nsmooth(geometry, model = spde_smooth, weights = w) +\nrough(geometry, model = spde_rough,  weights = I(1 - w))\n\nfit_ns <- bru(\ncomponents = cmp_ns,\nfamily = \"binomial\",\ndata = ns_dat,\nNtrials = ns_dat$n,\noptions = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_ns)\n```\n\n## 18.  Predict and map (clipped to Nigeria)\n\n```{r}\npred_grid_ns <- read_csv(\"data/prediction_grid_utm.csv\") %>% \nmutate(w = (utm_y - min(utm_y)) / (max(utm_y) - min(utm_y)),\nw = pmin(pmax(w, 0), 1)) %>%\nst_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\n\n\npred_ns_sf <- predict(fit_ns, newdata = pred_grid_ns, n.samples = 200,\n                      formula = ~ plogis(Intercept + elevation + ndvi + urban +\nw*smooth + (1-w)*rough)) |>\nrename(prev_mean = mean)\npred_ns_rast <- st_rasterize(pred_ns_sf[\"prev_mean\"], dx = 20000, dy = 20000)\npred_ns_rast_ng <- pred_ns_rast[st_union(nga_admin1)]\n\nggplot() +\ngeom_stars(data = pred_ns_rast_ng, na.rm = TRUE) +\ngeom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\ncoord_sf(expand = FALSE) +\nscale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\ntheme_minimal() +\ntheme(panel.grid = element_blank(),\npanel.background = element_rect(fill = \"white\", colour = NA),\nplot.background  = element_rect(fill = \"white\", colour = NA)) +\nlabs(title = \"Non-stationary mixture model: posterior mean prevalence\")\n```\n\n## 19.  (Optional) Visualise the weight surface $\\omega(s)$\n\n```{r}\nw_rast <- st_rasterize(pred_ns_sf[\"w\"], dx = 20000, dy = 20000)[st_union(nga_admin1)]\n\nggplot() +\ngeom_stars(data = w_rast, na.rm = TRUE) +\ngeom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\ncoord_sf(expand = FALSE) +\nscale_fill_viridis_c(name = \"w(s)\", limits = c(0, 1), na.value = NA) +\ntheme_minimal() +\ntheme(panel.grid = element_blank(),\npanel.background = element_rect(fill = \"white\", colour = NA),\nplot.background  = element_rect(fill = \"white\", colour = NA)) +\nlabs(title = \"Spatially varying weight w(s): smooth (north) → rough (south)\")\n```\n\n============================================================\n\n**Part 1B — Non-stationary SPDE with structured range**\n\n============================================================\n\nHere we make the SPDE range depend on a covariate at the mesh vertices by modelling log(kappa(s)) as: $$\\log(\\kappa(s)) = \\theta_0 + \\theta_1 z(s)$$ and since range(s) = $\\sqrt(8)/\\kappa(s)$, this gives a spatially varying range.\n\n## 20.  Mesh + vertex covariate\n\nUse something interpretable like northing (y) or a “ecological gradient”.\n\n```{r}\n# Mesh for nonstationary dataset\ncoords_ns <- st_coordinates(nonstat_malaria_sf)\n\nmesh_ns <- inla.mesh.2d(\n  loc = coords_ns,\n  max.edge = c(80000, 250000),\n  cutoff   = 20000,\n  offset   = c(100000, 200000)\n)\n\n# Vertex covariate: scaled northing at mesh vertices\nz_vert <- scale(mesh_ns$loc[,2])[,1]   # mesh vertex y coordinate (UTM northing)\n\n# Basis matrices for spatially varying kappa and/or tau\n# Here: 2 hyperparameters for kappa: intercept + slope*z\nB_kappa <- cbind(1, z_vert)\n\n# Keep tau constant (1 parameter) OR also vary it; here constant:\nB_tau <- matrix(1, nrow = nrow(B_kappa), ncol = 1)\n\n\n```\n\n## 21.  Build B.tau / B.kappa with 4 columns\n\nHere we use the Lindgren/Rue parameterisation.\n\n```{r}\nnu <- 1\nalpha <- nu + 2/2\n\n# constants for the SPDE parameterisation (same approach as the book)\nlogkappa0 <- log(8 * nu) / 2\n\nlogtau0 <- (lgamma(nu) - lgamma(alpha) - log(4*pi)) / 2\nlogtau0 <- logtau0 - logkappa0\n\nB_tau   <- cbind(logtau0,  -1,  nu,  nu * z_vert)\nB_kappa <- cbind(logkappa0, 0,  -1, -1 * z_vert)\n\n```\n\n\n\n\n## 22.  Build a non-stationary SPDE using inla.spde2.matern\n\nWe specify priors for the theta parameters. (These are on log-scales internally.)\n\n```{r}\nspde_ns <- inla.spde2.matern(\n  mesh = mesh_ns,\n  B.kappa = B_kappa,\n  B.tau   = B_tau,\n  theta.prior.mean = c(log(1/300000), 0, 0),   # (kappa intercept), (kappa slope), (tau intercept)\n  theta.prior.prec = c(1, 1, 1)                # weak-ish priors, Increasing theta.prior.prec tightens the prior (less variation).\n  # The seco4)  Predict and mapnd entry in theta.prior.mean / prec controls how strongly the range can vary with z.\n)\n```\n\n## 23.  Fit binomial model with this structured-range SPDE\n\n```{r}\n\ncmp_ns_struct <- y ~\n  1 + elevation + ndvi + urban +\n  field_ns(geometry, model = spde_ns)\n\nfit_ns_struct <- bru(\n  components = cmp_ns_struct,\n  family = \"binomial\",\n  data = ns_dat,\n  Ntrials = ns_dat$n_tested,\n  options = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_ns_struct)\n```\n\n## 24.  Predict and map\n\n```{r}\npred_ns_sf <- predict(fit_ns_struct, newdata = pred_grid_ns, n.samples = 200, \n                      ~ plogis(Intercept + elevation + ndvi + urban + field_ns)) |>\n  rename(prev_mean = mean)\n\npred_rast <- st_rasterize(pred_ns_sf[\"prev_mean\"], dx = 20000, dy = 20000)\npred_rast_ng <- pred_rast[st_union(nga_admin1)]   # mask outside Nigeria\n\n# --- (D) Plot ---\nggplot() +\n  geom_stars(data = pred_rast_ng, na.rm = TRUE) +\n  geom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\n  coord_sf(expand = FALSE) +\n  scale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    panel.background = element_rect(fill = \"white\", colour = NA),\n    plot.background  = element_rect(fill = \"white\", colour = NA)\n  ) +\n  labs(\n    title = \"Posterior mean malaria prevalence\",\n    subtitle = \"Non-stationary SPDE with structured range\"\n  )\n```\n\n# Summary (Day 2)\n\nJoint model: shared + group-specific spatial structure, two outcomes in one model\n\nNon-stationary model: mixture of SPDEs with a spatially varying weight and structured range.\n\nMapping: predictions rasterised and clipped to Nigeria boundary\n\n---\n","srcMarkdownNoYaml":"\n\n# Overview\n\nToday we will cover two key advanced topics in spatial modelling:\n\n1.  **Joint modelling** of multiple malaria processes\n    -   Shared spatial fields\\\n    -   Process-specific fields\\\n    -   Multiple outcomes (e.g., children vs pregnant women)\n    -   Multiple likelihoods (Binomial + Poisson)\n2.  **Non-stationary spatial processes**\n    -   Region-varying smoothness\\\n    -   Covariate-driven nonstationarity\\\n    -   Combining multiple spatial SPDEs\n\n------------------------------------------------------------------------\n\n## 1. Load Day 2 datasets\n\n```{r}\nlibrary(tidyverse)\nlibrary(INLA)\nlibrary(inlabru)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(stars)\nlibrary(geoR)\n\njoint_malaria <- read_csv(\"data/joint_malaria_processes.csv\")\nnonstat_malaria <- read_csv(\"data/nonstationary_malaria_data.csv\")\n\nnga_admin1 <- st_read(\"data/nga_shapefile.shp\")\n\nhead(joint_malaria)\n```\n\n## 2. Convert to sf for mapping\n\nWe need an `sf` layer to overlay boundaries, plot points, and feed coordinates into SPDE meshes.\n\n```{r}\njoint_malaria_sf <- joint_malaria %>%\n  st_as_sf(coords = c(\"utm_x\", \"utm_y\"), crs = 32632)\nnonstat_malaria_sf <- nonstat_malaria %>%\n  st_as_sf(coords = c(\"utm_x\", \"utm_y\"), crs = 32632)\n```\n\n## 3. Quick visualisation\n\n```{r}\nggplot() +\ngeom_sf(data = joint_malaria_sf, aes(colour = prevalence_true)) +\nfacet_wrap(~group) +\ngeom_sf(data = nga_admin1, fill = NA) +\ngeom_point() +\ntheme_minimal()\n```\n\nQuick visualisation (non-stationary dataset)\n\n```{r}\nggplot() +\ngeom_sf(data = nonstat_malaria_sf, aes(colour = prevalence_true)) +\ngeom_sf(data = nga_admin1, fill = NA) +\ngeom_point() +\ntheme_minimal()\n```\n\n============================================================\n\n**Part 1A — Joint modelling (shared + group-specific fields)**\n\n============================================================\n\n## 4.  Create a single stacked dataset\n\nWe will model both groups jointly with: - one shared spatial field - one group-specific spatial field (replicated by group)\n\n```{r}\njoint_dat <- joint_malaria_sf |>\nmutate(\ngroup = factor(group),\ny = n_pos,\nn = n_tested\n)\n\nlevels(joint_dat$group)\n```\n\n## 5.  Build SPDE mesh\n\n```{r}\nlocs_joint <- joint_malaria_sf\n\nmesh_joint <- inla.mesh.2d(\nloc = st_coordinates(locs_joint),\nmax.edge = c(80000, 250000),   # tune for smoothness vs speed\ncutoff = 20000,                # remove very close points\noffset = c(100000, 200000)\n)\n\nplot(mesh_joint)\npoints(st_coordinates(locs_joint), pch = 16, cex = 0.4, col= \"red\")\n```\n\n## 6.  Define SPDEs (shared + group-specific)\n\n-   spde_shared: one latent field for all data\n-   spde_group: replicated field with one replicate per group\n\n```{r}\nspde_shared <- inla.spde2.pcmatern(\nmesh = mesh_joint,\nprior.range = c(300000, 0.5),   # P(range < 300km) = 0.5\nprior.sigma = c(1, 0.5)         # P(sigma > 1) = 0.5\n)\n\nspde_group <- inla.spde2.pcmatern(\nmesh = mesh_joint,\nprior.range = c(200000, 0.5),\nprior.sigma = c(1, 0.5)\n)\n```\n\n## 7.  Fit joint model in inlabru\n\nModel:\n\n-   Binomial likelihood for counts\n-   Fixed effects (elevation, ndvi, urban)\n-   field_shared() applies to all\n-   field_group() replicated by group\n\n```{r}\ncmp_joint <- y ~\n1 +\nelevation + ndvi + urban +\nfield_shared(geometry, model = spde_shared) +\nfield_group(geometry, model = spde_group, replicate = group)\n\nfit_joint <- bru(\ncomponents = cmp_joint,\nfamily = \"binomial\",\ndata = joint_dat,\nNtrials = joint_dat$n,\noptions = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_joint)\n```\n\n## 8.  Prediction grid inside Nigeria (UTM)\n\n```{r}\n# make_grid_utm <- function(polygon_utm, dx = 20000) {\n# bb <- st_bbox(polygon_utm)\n# xs <- seq(bb[\"xmin\"], bb[\"xmax\"], by = dx)\n# ys <- seq(bb[\"ymin\"], bb[\"ymax\"], by = dx)\n# grid <- expand.grid(utm_x = xs, utm_y = ys)\n# pts  <- st_as_sf(grid, coords = c(\"utm_x\", \"utm_y\"), crs = st_crs(polygon_utm))\n# inside <- st_within(pts, polygon_utm, sparse = FALSE)[, 1]\n# grid[inside, ]\n# }\n# \n# pred_grid_joint <- make_grid_utm(nga_poly %>% st_transform(32632), dx = 100000) |>\n# mutate(\n# # For teaching: use simple smooth-ish covariates (replace with real rasters later)\n# elevation = 250 + 80 * scale(utm_y)[,1] + rnorm(n(), sd = 15),\n# ndvi      = plogis(-0.2 + 0.8 * scale(utm_y)[,1] + 0.3 * sin(scale(utm_x)[,1])),\n# urban     = rbinom(n(), 1, plogis(-0.2 + 0.3 * scale(utm_x)[,1]))\n# )\n\npred_grid_joint <- read_csv(\"data/prediction_grid_utm.csv\") %>% \ntidyr::expand_grid(group = levels(joint_dat$group)) %>%\nst_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\nhead(pred_grid_joint)\n```\n\n## 9.  Predict for each group and map\n\n```{r}\npred_joint <- predict(\nfit_joint,\nnewdata = pred_grid_joint,\nformula = ~ plogis(Intercept + elevation + ndvi + urban +\nfield_shared + field_group),\nn.samples = 200\n)\n\npred_joint_sf <- pred_joint |>\nrename(prev_mean = mean)\n\nhead(pred_joint_sf)\n```\n\n## 10.  Raster map per group (clipped to Nigeria)\n\n```{r}\npred_joint_map <- function(group_name, dx = 20000) {\ndat_g <- pred_joint_sf |> filter(group == group_name)\n\nrast <- st_rasterize(dat_g[\"prev_mean\"], dx = dx, dy = dx)\nrast_ng <- rast[st_union(nga_admin1)]\n\nggplot() +\ngeom_stars(data = rast_ng, na.rm = TRUE) +\ngeom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\ncoord_sf(expand = FALSE) +\nscale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\ntheme_minimal() +\ntheme(panel.grid = element_blank(),\npanel.background = element_rect(fill = \"white\", colour = NA),\nplot.background  = element_rect(fill = \"white\", colour = NA)) +\nlabs(title = paste(\"Joint model: posterior mean prevalence –\", group_name))\n}\n\npred_joint_map(\"children_u5\")\npred_joint_map(\"pregnant_women\")\n```\n\n============================================================\n\n**Part 2A — Joint modelling with multiple likelihoods (Binomial + Poisson)**\n\n============================================================\n\n## 11.  Prepare the two datasets and create the mesh\n\nHere we used the binomial and poisson malaria data: - spatial_binom with n_pos, n_tested - spatial_pois with cases, population\n\n```{r}\n# Example: take children as binomial and pretend pregnant are poisson (toy)\nbinom_dat <- read_csv(\"data/spatial_binomial_data.csv\") \npois_dat <- read_csv(\"data/spatial_poisson_data.csv\")\n\nbinom_sf <- st_as_sf(binom_dat, coords = c(\"utm_x\",\"utm_y\"), crs = 32632)\npois_sf  <- st_as_sf(pois_dat,  coords = c(\"utm_x\",\"utm_y\"), crs = 32632)\n\n\nmesh_binom <- inla.mesh.2d(\nloc = st_coordinates(binom_sf),\nmax.edge = c(100000, 200000), # inner and outer triangle sizes\ncutoff = 20000,  # merge points closer than 20km\noffset = c(50000, 200000)  # extend mesh beyond convex hull\n)\n\nplot(mesh_binom)\npoints(st_coordinates(binom_sf), col=\"red\", pch=16, cex = 0.4)\n\n\n####\nmesh_pois <- inla.mesh.2d(\nloc = st_coordinates(binom_sf),\nmax.edge = c(100000, 200000), # inner and outer triangle sizes\ncutoff = 20000,  # merge points closer than 20km\noffset = c(50000, 200000)  # extend mesh beyond convex hull\n)\n\nplot(mesh_pois)\npoints(st_coordinates(binom_sf), col=\"red\", pch=16, cex = 0.4)\n\n\n# Mesh on all locations\nall_coords <- rbind(st_coordinates(binom_sf), st_coordinates(pois_sf))\n\nmesh_joint <- inla.mesh.2d(\n  loc = all_coords,\n  max.edge = c(80000, 250000),\n  cutoff   = 20000,\n  offset   = c(100000, 200000)\n)\n\nplot(mesh_joint); points(all_coords, pch = 16, cex = 0.4, col=\"red\")\n```\n\n## 12.  Shared + likelihood-specific spatial fields\n\n```{r}\nspde_shared <- inla.spde2.pcmatern(\n  mesh = mesh_joint,\n  prior.range = c(300000, 0.5),\n  prior.sigma = c(1, 0.5)\n)\n\nspde_binom <- inla.spde2.pcmatern(\n  mesh = mesh_binom,\n  prior.range = c(200000, 0.5),\n  prior.sigma = c(1, 0.5)\n)\n\nspde_pois <- inla.spde2.pcmatern(\n  mesh = mesh_pois,\n  prior.range = c(200000, 0.5),\n  prior.sigma = c(1, 0.5)\n)\n```\n\n## 13.  Fit a multi-likelihood model in inlabru\n\nKey idea: use like() twice, and call bru() once.\n\n```{r}\n# Components: shared + outcome-specific fields\ncmp <- ~\n  Intercept_binom(1) + Intercept_pois(1) + \n  elevation + ndvi + urban +\n  shared(geometry, copy = \"binom_field\", fixed = FALSE) +\n  binom_field(geometry, model = spde_binom) +\n  pois_field(geometry,  model = spde_pois)\n\n# Likelihood 1: binomial prevalence\nlike_binom <- like(\n  formula = n_pos ~ Intercept_binom + elevation + ndvi + urban +\n  binom_field,\n  family  = \"binomial\",\n  data    = binom_sf,\n  Ntrials = binom_sf$n_tested\n)\n\n# Likelihood 2: poisson cases with offset(log(population))\nlike_pois <- like(\n  formula = cases ~ Intercept_pois + elevation + ndvi + urban +\n  shared +\n  pois_field, # + offset(log(population)),\n  family  = \"poisson\",\n  data    = pois_sf,\n  E = pois_sf$population\n)\n\nfit_multi <- bru(\n  components = cmp,\n  like_binom,\n  like_pois,\n  options = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_multi)\n```\n\n## 14.  Predict (example: prevalence surface from the binomial part)\n\n```{r}\npred_grid <- read_csv(\"data/prediction_grid_utm.csv\") %>%\nst_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\n\npred_binom_multi <- predict(\nfit_multi,\nnewdata = pred_grid,\nformula = ~ plogis(Intercept_binom + elevation + ndvi + urban + binom_field),\nn.samples = 1000\n)\n```\n\n```{r}\npred_binom_r <- st_rasterize(pred_binom_multi[\"mean\"], dx=10000, dy=10000)\npred_binom_r <- pred_binom_r[st_union(nga_admin1)]\nggplot() +\n  geom_stars(data=pred_binom_r, na.rm = TRUE) +\n  geom_sf(data=nga_admin1, fill=NA, color = \"black\") +\n  coord_sf() +\n  scale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = \"white\", colour = NA),\n    plot.background  = element_rect(fill = \"white\", colour = NA),\n    panel.grid       = element_blank()\n  )\n\n```\n\n============================================================\n\n**Part 1B — Non-stationary spatial process (mixture of two SPDEs)**\n\n============================================================ We’ll fit a non-stationary field using a mixture of two spatial fields:\n\n-   one smooth / long-range SPDE\n-   one rough / short-range SPDE\n-   a spatially varying weight w(s) controlling mixture\n\nThis is a simple, teachable non-stationary construction.\n\n## 15.  Prepare data and a mesh\n\n```{r}\nns_dat <- nonstat_malaria |>\nmutate(\ny = n_pos,\nn = n_tested\n)\n\nlocs_ns <- nonstat_malaria_sf\n\nmesh_ns <- inla.mesh.2d(\nloc = st_coordinates(locs_ns),\nmax.edge = c(80000, 250000),\ncutoff = 20000,\noffset = c(100000, 200000)\n)\n\nplot(mesh_ns)\npoints(st_coordinates(locs_ns), pch = 16, cex = 0.4, col= \"red\")\n```\n\n## 15.  Two SPDEs: smooth and rough\n\n```{r}\nspde_smooth <- inla.spde2.pcmatern(\nmesh = mesh_ns,\nprior.range = c(600000, 0.5),   # long range\nprior.sigma = c(1, 0.5)\n)\n\nspde_rough <- inla.spde2.pcmatern(\nmesh = mesh_ns,\nprior.range = c(200000, 0.5),   # short range\nprior.sigma = c(1, 0.5)\n)\n```\n\n## 16.  Build a spatially varying weight w(s)\n\nDefine w(s) as a simple function of northing (utm_y). (You can later replace this with a covariate surface.)\n\n```{r}\n# Normalised northing in [0,1]\n\nns_dat <- ns_dat |>\nmutate(\nw = (utm_y - min(utm_y)) / (max(utm_y) - min(utm_y)),\nw = pmin(pmax(w, 0), 1)\n) %>% st_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\nhead(ns_dat)\n```\n\n## 17.  Fit non-stationary mixture model\n\nWe model:\n\n$$\\eta = \\beta_0 + \\beta^\\top x(s) + \\omega(s) S_{smooth} + (1- \\omega(s)) S_{rough}(s)$$\n\nIn inlabru we do this by multiplying the fields by covariates w and 1-w.\n\n```{r}\ncmp_ns <- y ~\n1 + elevation + ndvi + urban +\nsmooth(geometry, model = spde_smooth, weights = w) +\nrough(geometry, model = spde_rough,  weights = I(1 - w))\n\nfit_ns <- bru(\ncomponents = cmp_ns,\nfamily = \"binomial\",\ndata = ns_dat,\nNtrials = ns_dat$n,\noptions = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_ns)\n```\n\n## 18.  Predict and map (clipped to Nigeria)\n\n```{r}\npred_grid_ns <- read_csv(\"data/prediction_grid_utm.csv\") %>% \nmutate(w = (utm_y - min(utm_y)) / (max(utm_y) - min(utm_y)),\nw = pmin(pmax(w, 0), 1)) %>%\nst_as_sf(coords=c(\"utm_x\",\"utm_y\"), crs=32632)\n\n\npred_ns_sf <- predict(fit_ns, newdata = pred_grid_ns, n.samples = 200,\n                      formula = ~ plogis(Intercept + elevation + ndvi + urban +\nw*smooth + (1-w)*rough)) |>\nrename(prev_mean = mean)\npred_ns_rast <- st_rasterize(pred_ns_sf[\"prev_mean\"], dx = 20000, dy = 20000)\npred_ns_rast_ng <- pred_ns_rast[st_union(nga_admin1)]\n\nggplot() +\ngeom_stars(data = pred_ns_rast_ng, na.rm = TRUE) +\ngeom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\ncoord_sf(expand = FALSE) +\nscale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\ntheme_minimal() +\ntheme(panel.grid = element_blank(),\npanel.background = element_rect(fill = \"white\", colour = NA),\nplot.background  = element_rect(fill = \"white\", colour = NA)) +\nlabs(title = \"Non-stationary mixture model: posterior mean prevalence\")\n```\n\n## 19.  (Optional) Visualise the weight surface $\\omega(s)$\n\n```{r}\nw_rast <- st_rasterize(pred_ns_sf[\"w\"], dx = 20000, dy = 20000)[st_union(nga_admin1)]\n\nggplot() +\ngeom_stars(data = w_rast, na.rm = TRUE) +\ngeom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\ncoord_sf(expand = FALSE) +\nscale_fill_viridis_c(name = \"w(s)\", limits = c(0, 1), na.value = NA) +\ntheme_minimal() +\ntheme(panel.grid = element_blank(),\npanel.background = element_rect(fill = \"white\", colour = NA),\nplot.background  = element_rect(fill = \"white\", colour = NA)) +\nlabs(title = \"Spatially varying weight w(s): smooth (north) → rough (south)\")\n```\n\n============================================================\n\n**Part 1B — Non-stationary SPDE with structured range**\n\n============================================================\n\nHere we make the SPDE range depend on a covariate at the mesh vertices by modelling log(kappa(s)) as: $$\\log(\\kappa(s)) = \\theta_0 + \\theta_1 z(s)$$ and since range(s) = $\\sqrt(8)/\\kappa(s)$, this gives a spatially varying range.\n\n## 20.  Mesh + vertex covariate\n\nUse something interpretable like northing (y) or a “ecological gradient”.\n\n```{r}\n# Mesh for nonstationary dataset\ncoords_ns <- st_coordinates(nonstat_malaria_sf)\n\nmesh_ns <- inla.mesh.2d(\n  loc = coords_ns,\n  max.edge = c(80000, 250000),\n  cutoff   = 20000,\n  offset   = c(100000, 200000)\n)\n\n# Vertex covariate: scaled northing at mesh vertices\nz_vert <- scale(mesh_ns$loc[,2])[,1]   # mesh vertex y coordinate (UTM northing)\n\n# Basis matrices for spatially varying kappa and/or tau\n# Here: 2 hyperparameters for kappa: intercept + slope*z\nB_kappa <- cbind(1, z_vert)\n\n# Keep tau constant (1 parameter) OR also vary it; here constant:\nB_tau <- matrix(1, nrow = nrow(B_kappa), ncol = 1)\n\n\n```\n\n## 21.  Build B.tau / B.kappa with 4 columns\n\nHere we use the Lindgren/Rue parameterisation.\n\n```{r}\nnu <- 1\nalpha <- nu + 2/2\n\n# constants for the SPDE parameterisation (same approach as the book)\nlogkappa0 <- log(8 * nu) / 2\n\nlogtau0 <- (lgamma(nu) - lgamma(alpha) - log(4*pi)) / 2\nlogtau0 <- logtau0 - logkappa0\n\nB_tau   <- cbind(logtau0,  -1,  nu,  nu * z_vert)\nB_kappa <- cbind(logkappa0, 0,  -1, -1 * z_vert)\n\n```\n\n\n\n\n## 22.  Build a non-stationary SPDE using inla.spde2.matern\n\nWe specify priors for the theta parameters. (These are on log-scales internally.)\n\n```{r}\nspde_ns <- inla.spde2.matern(\n  mesh = mesh_ns,\n  B.kappa = B_kappa,\n  B.tau   = B_tau,\n  theta.prior.mean = c(log(1/300000), 0, 0),   # (kappa intercept), (kappa slope), (tau intercept)\n  theta.prior.prec = c(1, 1, 1)                # weak-ish priors, Increasing theta.prior.prec tightens the prior (less variation).\n  # The seco4)  Predict and mapnd entry in theta.prior.mean / prec controls how strongly the range can vary with z.\n)\n```\n\n## 23.  Fit binomial model with this structured-range SPDE\n\n```{r}\n\ncmp_ns_struct <- y ~\n  1 + elevation + ndvi + urban +\n  field_ns(geometry, model = spde_ns)\n\nfit_ns_struct <- bru(\n  components = cmp_ns_struct,\n  family = \"binomial\",\n  data = ns_dat,\n  Ntrials = ns_dat$n_tested,\n  options = list(control.compute = list(dic = TRUE, waic = TRUE))\n)\n\nsummary(fit_ns_struct)\n```\n\n## 24.  Predict and map\n\n```{r}\npred_ns_sf <- predict(fit_ns_struct, newdata = pred_grid_ns, n.samples = 200, \n                      ~ plogis(Intercept + elevation + ndvi + urban + field_ns)) |>\n  rename(prev_mean = mean)\n\npred_rast <- st_rasterize(pred_ns_sf[\"prev_mean\"], dx = 20000, dy = 20000)\npred_rast_ng <- pred_rast[st_union(nga_admin1)]   # mask outside Nigeria\n\n# --- (D) Plot ---\nggplot() +\n  geom_stars(data = pred_rast_ng, na.rm = TRUE) +\n  geom_sf(data = nga_admin1, fill = NA, colour = \"black\", linewidth = 0.25) +\n  coord_sf(expand = FALSE) +\n  scale_fill_viridis_c(name = \"Predicted\\nprevalence\", na.value = NA) +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    panel.background = element_rect(fill = \"white\", colour = NA),\n    plot.background  = element_rect(fill = \"white\", colour = NA)\n  ) +\n  labs(\n    title = \"Posterior mean malaria prevalence\",\n    subtitle = \"Non-stationary SPDE with structured range\"\n  )\n```\n\n# Summary (Day 2)\n\nJoint model: shared + group-specific spatial structure, two outcomes in one model\n\nNon-stationary model: mixture of SPDEs with a spatially varying weight and structured range.\n\nMapping: predictions rasterised and clipped to Nigeria boundary\n\n---\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"day2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"cosmo","title":"Day 2 – Joint modelling and Non-stationary processes","author":"Olatunji Johnson","editor":"visual"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}